name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: my-eks-cluster-1
  DOCKER_IMAGE: devops-app
  NAMESPACE: devops-app
  TERRAFORM_VERSION: 1.5.0
  ECR_REPOSITORY: devops-app

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        cd app
        pip install -r requirements.txt
    
    - name: Test application
      run: |
        cd app
        python -c "import app; print('App imports successfully')"
        # Add your actual tests here
        python -m pytest tests/ -v

  terraform-apply:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Terraform Format Check with Auto-fix
      run: |
        cd infra/terraform
        terraform fmt -check || terraform fmt
        echo "Terraform files formatted"

    - name: Terraform Init
      id: init
      run: |
        cd infra/terraform
        terraform init

    - name: Terraform Validate
      id: validate
      run: |
        cd infra/terraform
        terraform validate -no-color

    - name: Terraform Plan
      id: plan
      run: |
        cd infra/terraform
        terraform plan -no-color -out=tfplan

    - name: Terraform Apply
      run: |
        cd infra/terraform
        terraform apply -auto-approve tfplan

    - name: Wait for EKS cluster to be active
      run: |
        echo "Waiting for EKS cluster to become active..."
        for i in {1..35}; do
          CLUSTER_STATUS=$(aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query "cluster.status" --output text 2>/dev/null || echo "CREATING")
          echo "Cluster status: $CLUSTER_STATUS"
          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "‚úÖ EKS cluster is now ACTIVE"
            break
          fi
          if [ $i -eq 35 ]; then
            echo "‚ùå Timeout waiting for cluster to become active"
            exit 1
          fi
          sleep 20
        done

    - name: Wait for node group to be ready
      run: |
        echo "Waiting for node group to become active..."
        for i in {1..20}; do
          NODE_STATUS=$(aws eks describe-nodegroup --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name my-node-group-my-eks-cluster-1 --region ${{ env.AWS_REGION }} --query "nodegroup.status" --output text 2>/dev/null || echo "CREATING")
          echo "Node group status: $NODE_STATUS"
          if [ "$NODE_STATUS" = "ACTIVE" ]; then
            echo "‚úÖ Node group is now ACTIVE"
            break
          fi
          if [ $i -eq 20 ]; then
            echo "‚ùå Timeout waiting for node group to become active"
            exit 1
          fi
          sleep 15
        done

    - name: Update kubeconfig after cluster creation
      run: |
        echo "Updating kubeconfig for the newly created cluster..."
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
        echo "‚úÖ Kubeconfig updated successfully"
        
    - name: Verify cluster access
      run: |
        echo "Verifying cluster access..."
        kubectl cluster-info
        kubectl get nodes
        echo "‚úÖ Cluster access verified"

    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        echo "‚úÖ Namespace created"

  build-and-push:
    needs: terraform-apply
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      image-uri: ${{ steps.set-ecr-output.outputs.image-uri }}
      image-uri-latest: ${{ steps.set-ecr-output.outputs.image-uri-latest }}
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build Docker image
      run: |
        cd app
        docker build -t ${{ env.DOCKER_IMAGE }}:${{ github.sha }} .
        docker tag ${{ env.DOCKER_IMAGE }}:${{ github.sha }} ${{ env.DOCKER_IMAGE }}:latest
        echo "‚úÖ Docker image built and tagged"

    - name: Get ECR registry info
      id: ecr-info
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        ECR_REGISTRY=$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
        echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV

    - name: Create ECR repository if not exists
      run: |
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }}
        echo "‚úÖ ECR repository ensured"

    - name: Tag and Push Docker images to ECR
      run: |
        # Tag images with ECR registry
        docker tag ${{ env.DOCKER_IMAGE }}:${{ github.sha }} $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
        docker tag ${{ env.DOCKER_IMAGE }}:latest $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest
        
        # Push both tags
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
        docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest
        
        echo "‚úÖ Docker images pushed to ECR"

    - name: Set ECR image output
      id: set-ecr-output
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        ECR_REGISTRY=$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
        echo "image-uri=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "image-uri-latest=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest" >> $GITHUB_OUTPUT
        echo "‚úÖ ECR image outputs set"

    - name: Display pushed images
      run: |
        echo "üì¶ Pushed Images:"
        echo "Specific version: ${{ steps.set-ecr-output.outputs.image-uri }}"
        echo "Latest version: ${{ steps.set-ecr-output.outputs.image-uri-latest }}"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
        echo "‚úÖ Kubeconfig updated"

    - name: Display deployment info
      run: |
        echo "üöÄ Deployment Information:"
        echo "Cluster: ${{ env.CLUSTER_NAME }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
        echo "Image URI: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "Image URI Latest: ${{ needs.build-and-push.outputs.image-uri-latest }}"

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        echo "‚úÖ Namespace ensured"

    - name: Prepare Kubernetes manifests
      run: |
        echo "Preparing Kubernetes manifests..."
        
        # Check if deployment.yaml exists
        if [ -f "infra/kubernetes/deployment.yaml" ]; then
          # Create a backup
          cp infra/kubernetes/deployment.yaml infra/kubernetes/deployment.yaml.backup
          
          # Replace IMAGE_PLACEHOLDER with actual ECR image URI
          sed -i "s|IMAGE_PLACEHOLDER|${{ needs.build-and-push.outputs.image-uri }}|g" infra/kubernetes/deployment.yaml
          
          echo "‚úÖ Updated deployment.yaml with image: ${{ needs.build-and-push.outputs.image-uri }}"
          echo "Updated deployment image section:"
          grep -A 5 -B 5 "image:" infra/kubernetes/deployment.yaml || true
        else
          echo "‚ùå deployment.yaml not found at infra/kubernetes/deployment.yaml"
          ls -la infra/kubernetes/ || echo "Kubernetes directory not found"
          exit 1
        fi

    - name: Deploy to Kubernetes
      run: |
        echo "Applying Kubernetes manifests..."
        
        if [ -d "infra/kubernetes/" ]; then
          # Apply all Kubernetes manifests
          kubectl apply -f infra/kubernetes/ -n ${{ env.NAMESPACE }} --validate=false
          echo "‚úÖ Kubernetes manifests applied from infra/kubernetes/"
        else
          echo "‚ùå Kubernetes manifests directory not found at infra/kubernetes/"
          exit 1
        fi

    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        
        # Wait for deployment to complete
        kubectl rollout status deployment/${{ env.DOCKER_IMAGE }} -n ${{ env.NAMESPACE }} --timeout=300s
        
        # Display deployment status
        echo "üìä Deployment Status:"
        kubectl get deployments,replicasets,pods -n ${{ env.NAMESPACE }}
        
        # Display service information
        echo "üåê Service Information:"
        kubectl get services -n ${{ env.NAMESPACE }} -o wide
        
        echo "‚úÖ Deployment verified successfully"

    - name: Run smoke test
      run: |
        echo "Running smoke tests..."
        
        # Get the application URL (if using LoadBalancer)
        SERVICE_URL=$(kubectl get service ${{ env.DOCKER_IMAGE }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        
        if [ -n "$SERVICE_URL" ]; then
          echo "Application URL: http://$SERVICE_URL"
          # Add actual smoke test commands here
          # Example: curl -f http://$SERVICE_URL/health || exit 1
        else
          echo "Service URL not available (might be ClusterIP type)"
        fi
        
        # Check pod logs for errors
        echo "üìã Pod Logs (last 10 lines):"
        kubectl logs -n ${{ env.NAMESPACE }} -l app=${{ env.DOCKER_IMAGE }} --tail=10 || true

    - name: Display completion message
      run: |
        echo "üéâ CI/CD Pipeline Completed Successfully!"
        echo ""
        echo "üìã Summary:"
        echo "  ‚úÖ Tests passed"
        echo "  ‚úÖ Infrastructure provisioned"
        echo "  ‚úÖ Docker image built and pushed to ECR"
        echo "  ‚úÖ Application deployed to EKS"
        echo ""
        echo "üîó ECR Image: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "üè∑Ô∏è  Image Tags: ${{ github.sha }}, latest"
        echo "üìä To check your application:"
        echo "   kubectl get pods,svc -n ${{ env.NAMESPACE }}"
        echo "   kubectl logs -n ${{ env.NAMESPACE }} -l app=${{ env.DOCKER_IMAGE }}"
